\section{Integrazione}

L’analisi esplorativa dei due datasets, anche in vista dell’applicazione dei metodi di Machine Learning, ha prodotto come risultato due nuovi datasets composti da un insieme ridotto di attributi, ritenuti rilevanti e non ridondanti per lo studio e gli obiettivi prefissati. Il numero di record è rimasto inalterato.
\par
L’integrazione dei due nuovi datasets ha avuto luogo in due passi separati. Inizialmente, sono stati utilizzati con una componente \textit{tMap} per associare al dataset dei tiri le statistiche degli attaccanti. Dopodiché, questo dataset consistente dei nuovi attributi è stato utilizzato assieme al dataset delle statistiche per associare, con un altro componente tMap, le informazioni relative al difensore.
\par
Non utilizzando un id univoco che identifica un giocatore per effettuare l’integrazione tra i due datasets ma i nomi stessi degli atleti, abbiamo optato per l’utilizzo della stessa funzione descritta nel paragrafo \textit{Preparazione dati}, così da uniformare i nomi presenti (scritti in minuscolo ordinati lessicograficamente) nei due datasets. 
\par
Effettuata l’integrazione, per verificare la consistenza del matching ad ogni passo è stato creato un file denominato \textit{rejected} in cui sono state inserite le istanze respinte, non trovando corrispondenza perfetta.
\par
Circa una decina di nomi sono risultati in questa lista. Questi casi sono stati risolti manualmente nella routine \texttt{EditShotLogs\_0.1.java}, eseguita in pipeline da Talend, poichè sarebbe stato problematico e dispendioso usare funzioni di edit distance appositamente parametrizzate per così pochi e particolari casi

\begin{code}
\captionof{listing}{Metodo matchNames da EditShotLogs\_0.1.java}
\begin{minted}{java}
public static String matchNames(String name1) {
	String[] def = {"Barea, Jose Juan", "Hardaway Jr., Tim", 
		"Aminu, Al-Farouq", "Nene", "Mbah a Moute, Luc",
		"Hayes, Charles", "Lucas III, John", "Taylor, Jeff",
		"Rice Jr., Glen", "Datome, Gigi", "McAdoo, James Michael"};
	String[] stats = {"J.J. Barea", "Tim Hardaway", 
		"Al-Farouq Aminu", "Nene Hilario", "Luc Mbah",
		"Chuck Hayes", "John Lucas", "Jeffery Taylor",
		"Glen Rice", "Luigi Datome", "James Michael"};
	String[] results = {"barea jj", "hardaway tim", 
		"al-farouq aminu", "nene hilario", "luc mbah",
		"chuck hayes", "john lucas", "jeffery taylor",
		"glen rice", "datome luigi", "james mcadoo michael"};
	if (Arrays.asList(def).contains(name1) || 
		Arrays.asList(stats).contains(name1)) {
		for (int i = 0; i < def.length; i++) {
			if (name1.equals(def[i]) || 
				name1.equals(stats[i])) {
				return results[i];
			}
		}  
	}
	String[] names1 = name1.replaceAll("[^a-zA-Z ]", "")
		.toLowerCase().split("\\s+");
	Arrays.sort(names1);
	String nuova = "";
	for (int i = 0; i < names1.length; i++) {
		nuova += names1[i];
		nuova += " ";
	}
	nuova = nuova.trim();
	return nuova;
}
\end{minted}
\end{code}

% todo aggiungere esempi di mismatch così si capisce che non aveva senso fare la funzione

\subsection{Misure di qualità del dataset integrato}
