\section{Integrazione}
\label{integrazione}

L’analisi esplorativa dei due datasets, anche in vista dell’applicazione dei metodi di Machine Learning, ha prodotto come risultato due nuovi datasets composti da un insieme ridotto di attributi, ritenuti rilevanti e non ridondanti per lo studio e gli obiettivi prefissati. Il numero di record è rimasto inalterato.
\par
L’integrazione dei due nuovi datasets ha avuto luogo in due passi separati. Inizialmente, sono stati utilizzati con una componente \textit{tMap} per associare al dataset dei tiri le statistiche degli attaccanti. Dopodiché, questo dataset consistente dei nuovi attributi è stato utilizzato assieme al dataset delle statistiche per associare, con un altro componente \textit{tMap}, le informazioni relative al difensore.
\par
\begin{figure}[H]
\caption{Pipeline d'integrazione dati implementata con \textit{Talend Studio}}
	\includegraphics[width=\linewidth]{pipeline_talend1.png}
\end{figure}

Non utilizzando un id univoco che identifica un giocatore per effettuare l’integrazione tra i due datasets ma i nomi stessi degli atleti, abbiamo optato per l’utilizzo della stessa funzione descritta nella \autoref{preparazione}, così da uniformare i nomi presenti (scritti in minuscolo ordinati lessicograficamente) nei due datasets. 
\par



Effettuata l’integrazione, per verificare la consistenza del matching ad ogni passo è stato creato un file denominato \textit{rejected} in cui sono state inserite le istanze respinte, non trovando corrispondenza perfetta.
\par
Circa una decina di nomi sono risultati in questa lista: sono risolti manualmente nella routine \texttt{EditShotLogs\_0.1.java}, eseguita in pipeline da Talend, poichè sarebbe stato problematico e dispendioso usare funzioni di edit distance appositamente parametrizzate per così pochi e particolari casi.

\begin{code}
\captionof{listing}{Metodo matchNames da EditShotLogs\_0.1.java}
\begin{minted}{java}
public static String matchNames(String name1) {
	String[] def = {"Barea, Jose Juan", "Hardaway Jr., Tim", 
		"Aminu, Al-Farouq", "Nene", "Mbah a Moute, Luc",
		"Hayes, Charles", "Lucas III, John", "Taylor, Jeff",
		"Rice Jr., Glen", "Datome, Gigi", "McAdoo, James Michael"};
	String[] stats = {"J.J. Barea", "Tim Hardaway", 
		"Al-Farouq Aminu", "Nene Hilario", "Luc Mbah",
		"Chuck Hayes", "John Lucas", "Jeffery Taylor",
		"Glen Rice", "Luigi Datome", "James Michael"};
	String[] results = {"barea jj", "hardaway tim", 
		"al-farouq aminu", "nene hilario", "luc mbah",
		"chuck hayes", "john lucas", "jeffery taylor",
		"glen rice", "datome luigi", "james mcadoo michael"};
	if (Arrays.asList(def).contains(name1) || 
		Arrays.asList(stats).contains(name1)) {
		for (int i = 0; i < def.length; i++) {
			if (name1.equals(def[i]) || 
				name1.equals(stats[i])) {
				return results[i];
			}
		}  
	}
	String[] names1 = name1.replaceAll("[^a-zA-Z ]", "")
		.toLowerCase().split("\\s+");
	Arrays.sort(names1);
	String nuova = "";
	for (int i = 0; i < names1.length; i++) {
		nuova += names1[i];
		nuova += " ";
	}
	nuova = nuova.trim();
	return nuova;
}
\end{minted}
\end{code}

% todo aggiungere esempi di mismatch così si capisce che non aveva senso fare la funzione

\subsection{Misure di qualità del dataset integrato}

\subsubsection{Currency, Volatility e Timeliness}
Un aspetto importante dei dati coinvolti nel nostro processo di integrazione è il loro cambiamento nel tempo. I database a nostra disposizione contemplano l’anno di campionato 2014-2015 ma è ovvio che questi vengano continuamente aggiornati e integrati con il corso dei campionati.

\textit{Currency}, definita come la velocità degli aggiornamenti \cite{batini2006}, ed una suo metrica è calcolabile con la seguente formula\cite{doi:10.1287/mnsc.44.4.462}
$$Currency = Age + (DeliveryTime - InputTime)$$
\textit{Age} misura l'età dei dati quando vengono ricevuti, \textit{DeliveryTime} è l'istante in cui il prodotto che utilizza queste informazioni è consegnato all'utente finale mentre \textit{InputTime} è l'istante in cui il dato è stato effettivamente ottenuto.
Il termine $(DeliveryTime - InputTime)$ misura quindi il periodo di tempo che trascore prima che il prodotto che utilizza i nostri dati sia pronto ed effettivamente utilizzabile.

Poichè l’anno corrente è 2019, i dati hanno una \textit{Age} di 4 anni. $(DeliveryTime - InputTime)$ risulta quindi trascurabile e \textit{Currency} è equivalente  ad \textit{Age}.

Supponiamo inoltre che le statistiche dell’NBA rimangano rilevanti per le 3 stagioni successive, la \textit{volatilità} dei dati è uguale a 3 anni.

\textit{Timeliness}, calcolata con 

$$\max\{{0, 1 - \frac{Currency}{Volatility}}\}$$

Vale quindi 0, rappresentando una cattiva tempestività del nostro dataset.

% dare rilevanza rispetto alla currency

\subsubsection{Completability}
Essendo i nostri dataset originari di servizi Web e riflettendo eventi reali distribuiti durante l'anno, ne vengono costantemente pubblicate versioni aggiornate.

La \textit{Completabilità} è un'interessante metrica che ci permette di visualizzare la dinamica di evoluzione temporale della completezza.

Consideriamo una funzione $C(t)$, definita come il valore della completezza all'istante t, con $t \in [t\_pub, t\_max]$, con $t\_pub$


cation of data and t max corresponds to the maximum time within which the
series of the different scheduled updates will be completed. Starting from the


$C_t$ \cite{batini2006}

$$\int_{t\_curr}^{t\_max} C_t$$

Per dare un'idea di che Completabilità esibiscono i dataset che consideriamo, indipendenemente dalla stagione a cui si riferiscono, supponiamo che:


\begin{itemize}
	\item Il ritardo con cui otteniamo i dati sia trascurabile, i.e. ad un istante $t$ abbiamo i dati delle partite fino a $t-1$;
\end{itemize}

	La completezza dei dati, in un istante \textit{t}, è data da $$ C_t = \frac{\sum\limits_{y=c-p-1}^{c-1} M_{y} + m_{c,t}}{\sum\limits_{y=c-p-1}^{c} M_{y}} \times 100 $$
	Dove \begin{itemize}
		\item $M_y$ è il numero totale di partite nella stagione $y$;
		\item $m_{c,t}$ il numero totale di partite nella stagione $y$ fino all'istante $t$;
		\item $c$ la stagione considerata
		\item $p$ numero di stagioni precedenti a quella che si vuole considerare che si suppongono rilevanti e parte del dataset.
	\end{itemize}

Considerando tutti gli istanti t in cui siano giocate delle partite, ottenute da \cite{schedule2019} e utilizzando y = 2019, c = 3 (considerando quindi i dati delle stagioni 2019, 2018, 2017, 2016, con 2019 stagione oggetto del dataset), la completezza evolve secondo la \autoref{completabilitypic}.

Completabilità è definita dall'area segnata come \textit{Cb}.

\begin{figure}
\caption{Rappresentazione grafica della completabilità}
\label{completabilitypic}
\includegraphics[width=\linewidth]{completability}
\end{figure}